// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testhelpers

import (
	"github.com/cello-proj/cello/service/internal/credentials"
	"sync"
)

// Ensure, that CredsProviderMock does implement credentials.Provider.
// If this is not the case, regenerate this file with moq.
var _ credentials.Provider = &CredsProviderMock{}

// CredsProviderMock is a mock implementation of credentials.Provider.
//
//	func TestSomethingThatUsesProvider(t *testing.T) {
//
//		// make and configure a mocked credentials.Provider
//		mockedProvider := &CredsProviderMock{
//			CreateProjectFunc: func(createProjectInput credentials.CreateProjectInput) (credentials.CreateProjectOutput, error) {
//				panic("mock out the CreateProject method")
//			},
//			CreateTargetFunc: func(createTargetInput credentials.CreateTargetInput) (credentials.CreateTargetOutput, error) {
//				panic("mock out the CreateTarget method")
//			},
//			CreateTokenFunc: func(createTokenInput credentials.CreateTokenInput) (credentials.CreateTokenOutput, error) {
//				panic("mock out the CreateToken method")
//			},
//			DeleteProjectFunc: func(deleteProjectInput credentials.DeleteProjectInput) (credentials.DeleteProjectOutput, error) {
//				panic("mock out the DeleteProject method")
//			},
//			DeleteProjectTokenFunc: func(deleteProjectTokenInput credentials.DeleteProjectTokenInput) (credentials.DeleteProjectTokenOutput, error) {
//				panic("mock out the DeleteProjectToken method")
//			},
//			DeleteTargetFunc: func(deleteTargetInput credentials.DeleteTargetInput) (credentials.DeleteTargetOutput, error) {
//				panic("mock out the DeleteTarget method")
//			},
//			GetProjectFunc: func(getProjectInput credentials.GetProjectInput) (credentials.GetProjectOutput, error) {
//				panic("mock out the GetProject method")
//			},
//			GetTargetFunc: func(getTargetInput credentials.GetTargetInput) (credentials.GetTargetOutput, error) {
//				panic("mock out the GetTarget method")
//			},
//			GetTokenFunc: func(getTokenInput credentials.GetTokenInput) (credentials.GetTokenOutput, error) {
//				panic("mock out the GetToken method")
//			},
//			HealthCheckFunc: func() (credentials.HealthCheckOutput, error) {
//				panic("mock out the HealthCheck method")
//			},
//			ListTargetsFunc: func(listTargetsInput credentials.ListTargetsInput) (credentials.ListTargetsOutput, error) {
//				panic("mock out the ListTargets method")
//			},
//			ProjectExistsFunc: func(projectExistsInput credentials.ProjectExistsInput) (credentials.ProjectExistsOutput, error) {
//				panic("mock out the ProjectExists method")
//			},
//			ProjectTokenExistsFunc: func(projectTokenExistsInput credentials.ProjectTokenExistsInput) (credentials.ProjectTokenExistsOutput, error) {
//				panic("mock out the ProjectTokenExists method")
//			},
//			TargetExistsFunc: func(targetExistsInput credentials.TargetExistsInput) (credentials.TargetExistsOutput, error) {
//				panic("mock out the TargetExists method")
//			},
//			UpdateTargetFunc: func(updateTargetInput credentials.UpdateTargetInput) (credentials.UpdateTargetOutput, error) {
//				panic("mock out the UpdateTarget method")
//			},
//		}
//
//		// use mockedProvider in code that requires credentials.Provider
//		// and then make assertions.
//
//	}
type CredsProviderMock struct {
	// CreateProjectFunc mocks the CreateProject method.
	CreateProjectFunc func(createProjectInput credentials.CreateProjectInput) (credentials.CreateProjectOutput, error)

	// CreateTargetFunc mocks the CreateTarget method.
	CreateTargetFunc func(createTargetInput credentials.CreateTargetInput) (credentials.CreateTargetOutput, error)

	// CreateTokenFunc mocks the CreateToken method.
	CreateTokenFunc func(createTokenInput credentials.CreateTokenInput) (credentials.CreateTokenOutput, error)

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(deleteProjectInput credentials.DeleteProjectInput) (credentials.DeleteProjectOutput, error)

	// DeleteProjectTokenFunc mocks the DeleteProjectToken method.
	DeleteProjectTokenFunc func(deleteProjectTokenInput credentials.DeleteProjectTokenInput) (credentials.DeleteProjectTokenOutput, error)

	// DeleteTargetFunc mocks the DeleteTarget method.
	DeleteTargetFunc func(deleteTargetInput credentials.DeleteTargetInput) (credentials.DeleteTargetOutput, error)

	// GetProjectFunc mocks the GetProject method.
	GetProjectFunc func(getProjectInput credentials.GetProjectInput) (credentials.GetProjectOutput, error)

	// GetTargetFunc mocks the GetTarget method.
	GetTargetFunc func(getTargetInput credentials.GetTargetInput) (credentials.GetTargetOutput, error)

	// GetTokenFunc mocks the GetToken method.
	GetTokenFunc func(getTokenInput credentials.GetTokenInput) (credentials.GetTokenOutput, error)

	// HealthCheckFunc mocks the HealthCheck method.
	HealthCheckFunc func() (credentials.HealthCheckOutput, error)

	// ListTargetsFunc mocks the ListTargets method.
	ListTargetsFunc func(listTargetsInput credentials.ListTargetsInput) (credentials.ListTargetsOutput, error)

	// ProjectExistsFunc mocks the ProjectExists method.
	ProjectExistsFunc func(projectExistsInput credentials.ProjectExistsInput) (credentials.ProjectExistsOutput, error)

	// ProjectTokenExistsFunc mocks the ProjectTokenExists method.
	ProjectTokenExistsFunc func(projectTokenExistsInput credentials.ProjectTokenExistsInput) (credentials.ProjectTokenExistsOutput, error)

	// TargetExistsFunc mocks the TargetExists method.
	TargetExistsFunc func(targetExistsInput credentials.TargetExistsInput) (credentials.TargetExistsOutput, error)

	// UpdateTargetFunc mocks the UpdateTarget method.
	UpdateTargetFunc func(updateTargetInput credentials.UpdateTargetInput) (credentials.UpdateTargetOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateProject holds details about calls to the CreateProject method.
		CreateProject []struct {
			// CreateProjectInput is the createProjectInput argument value.
			CreateProjectInput credentials.CreateProjectInput
		}
		// CreateTarget holds details about calls to the CreateTarget method.
		CreateTarget []struct {
			// CreateTargetInput is the createTargetInput argument value.
			CreateTargetInput credentials.CreateTargetInput
		}
		// CreateToken holds details about calls to the CreateToken method.
		CreateToken []struct {
			// CreateTokenInput is the createTokenInput argument value.
			CreateTokenInput credentials.CreateTokenInput
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// DeleteProjectInput is the deleteProjectInput argument value.
			DeleteProjectInput credentials.DeleteProjectInput
		}
		// DeleteProjectToken holds details about calls to the DeleteProjectToken method.
		DeleteProjectToken []struct {
			// DeleteProjectTokenInput is the deleteProjectTokenInput argument value.
			DeleteProjectTokenInput credentials.DeleteProjectTokenInput
		}
		// DeleteTarget holds details about calls to the DeleteTarget method.
		DeleteTarget []struct {
			// DeleteTargetInput is the deleteTargetInput argument value.
			DeleteTargetInput credentials.DeleteTargetInput
		}
		// GetProject holds details about calls to the GetProject method.
		GetProject []struct {
			// GetProjectInput is the getProjectInput argument value.
			GetProjectInput credentials.GetProjectInput
		}
		// GetTarget holds details about calls to the GetTarget method.
		GetTarget []struct {
			// GetTargetInput is the getTargetInput argument value.
			GetTargetInput credentials.GetTargetInput
		}
		// GetToken holds details about calls to the GetToken method.
		GetToken []struct {
			// GetTokenInput is the getTokenInput argument value.
			GetTokenInput credentials.GetTokenInput
		}
		// HealthCheck holds details about calls to the HealthCheck method.
		HealthCheck []struct {
		}
		// ListTargets holds details about calls to the ListTargets method.
		ListTargets []struct {
			// ListTargetsInput is the listTargetsInput argument value.
			ListTargetsInput credentials.ListTargetsInput
		}
		// ProjectExists holds details about calls to the ProjectExists method.
		ProjectExists []struct {
			// ProjectExistsInput is the projectExistsInput argument value.
			ProjectExistsInput credentials.ProjectExistsInput
		}
		// ProjectTokenExists holds details about calls to the ProjectTokenExists method.
		ProjectTokenExists []struct {
			// ProjectTokenExistsInput is the projectTokenExistsInput argument value.
			ProjectTokenExistsInput credentials.ProjectTokenExistsInput
		}
		// TargetExists holds details about calls to the TargetExists method.
		TargetExists []struct {
			// TargetExistsInput is the targetExistsInput argument value.
			TargetExistsInput credentials.TargetExistsInput
		}
		// UpdateTarget holds details about calls to the UpdateTarget method.
		UpdateTarget []struct {
			// UpdateTargetInput is the updateTargetInput argument value.
			UpdateTargetInput credentials.UpdateTargetInput
		}
	}
	lockCreateProject      sync.RWMutex
	lockCreateTarget       sync.RWMutex
	lockCreateToken        sync.RWMutex
	lockDeleteProject      sync.RWMutex
	lockDeleteProjectToken sync.RWMutex
	lockDeleteTarget       sync.RWMutex
	lockGetProject         sync.RWMutex
	lockGetTarget          sync.RWMutex
	lockGetToken           sync.RWMutex
	lockHealthCheck        sync.RWMutex
	lockListTargets        sync.RWMutex
	lockProjectExists      sync.RWMutex
	lockProjectTokenExists sync.RWMutex
	lockTargetExists       sync.RWMutex
	lockUpdateTarget       sync.RWMutex
}

// CreateProject calls CreateProjectFunc.
func (mock *CredsProviderMock) CreateProject(createProjectInput credentials.CreateProjectInput) (credentials.CreateProjectOutput, error) {
	if mock.CreateProjectFunc == nil {
		panic("CredsProviderMock.CreateProjectFunc: method is nil but Provider.CreateProject was just called")
	}
	callInfo := struct {
		CreateProjectInput credentials.CreateProjectInput
	}{
		CreateProjectInput: createProjectInput,
	}
	mock.lockCreateProject.Lock()
	mock.calls.CreateProject = append(mock.calls.CreateProject, callInfo)
	mock.lockCreateProject.Unlock()
	return mock.CreateProjectFunc(createProjectInput)
}

// CreateProjectCalls gets all the calls that were made to CreateProject.
// Check the length with:
//
//	len(mockedProvider.CreateProjectCalls())
func (mock *CredsProviderMock) CreateProjectCalls() []struct {
	CreateProjectInput credentials.CreateProjectInput
} {
	var calls []struct {
		CreateProjectInput credentials.CreateProjectInput
	}
	mock.lockCreateProject.RLock()
	calls = mock.calls.CreateProject
	mock.lockCreateProject.RUnlock()
	return calls
}

// CreateTarget calls CreateTargetFunc.
func (mock *CredsProviderMock) CreateTarget(createTargetInput credentials.CreateTargetInput) (credentials.CreateTargetOutput, error) {
	if mock.CreateTargetFunc == nil {
		panic("CredsProviderMock.CreateTargetFunc: method is nil but Provider.CreateTarget was just called")
	}
	callInfo := struct {
		CreateTargetInput credentials.CreateTargetInput
	}{
		CreateTargetInput: createTargetInput,
	}
	mock.lockCreateTarget.Lock()
	mock.calls.CreateTarget = append(mock.calls.CreateTarget, callInfo)
	mock.lockCreateTarget.Unlock()
	return mock.CreateTargetFunc(createTargetInput)
}

// CreateTargetCalls gets all the calls that were made to CreateTarget.
// Check the length with:
//
//	len(mockedProvider.CreateTargetCalls())
func (mock *CredsProviderMock) CreateTargetCalls() []struct {
	CreateTargetInput credentials.CreateTargetInput
} {
	var calls []struct {
		CreateTargetInput credentials.CreateTargetInput
	}
	mock.lockCreateTarget.RLock()
	calls = mock.calls.CreateTarget
	mock.lockCreateTarget.RUnlock()
	return calls
}

// CreateToken calls CreateTokenFunc.
func (mock *CredsProviderMock) CreateToken(createTokenInput credentials.CreateTokenInput) (credentials.CreateTokenOutput, error) {
	if mock.CreateTokenFunc == nil {
		panic("CredsProviderMock.CreateTokenFunc: method is nil but Provider.CreateToken was just called")
	}
	callInfo := struct {
		CreateTokenInput credentials.CreateTokenInput
	}{
		CreateTokenInput: createTokenInput,
	}
	mock.lockCreateToken.Lock()
	mock.calls.CreateToken = append(mock.calls.CreateToken, callInfo)
	mock.lockCreateToken.Unlock()
	return mock.CreateTokenFunc(createTokenInput)
}

// CreateTokenCalls gets all the calls that were made to CreateToken.
// Check the length with:
//
//	len(mockedProvider.CreateTokenCalls())
func (mock *CredsProviderMock) CreateTokenCalls() []struct {
	CreateTokenInput credentials.CreateTokenInput
} {
	var calls []struct {
		CreateTokenInput credentials.CreateTokenInput
	}
	mock.lockCreateToken.RLock()
	calls = mock.calls.CreateToken
	mock.lockCreateToken.RUnlock()
	return calls
}

// DeleteProject calls DeleteProjectFunc.
func (mock *CredsProviderMock) DeleteProject(deleteProjectInput credentials.DeleteProjectInput) (credentials.DeleteProjectOutput, error) {
	if mock.DeleteProjectFunc == nil {
		panic("CredsProviderMock.DeleteProjectFunc: method is nil but Provider.DeleteProject was just called")
	}
	callInfo := struct {
		DeleteProjectInput credentials.DeleteProjectInput
	}{
		DeleteProjectInput: deleteProjectInput,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(deleteProjectInput)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedProvider.DeleteProjectCalls())
func (mock *CredsProviderMock) DeleteProjectCalls() []struct {
	DeleteProjectInput credentials.DeleteProjectInput
} {
	var calls []struct {
		DeleteProjectInput credentials.DeleteProjectInput
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// DeleteProjectToken calls DeleteProjectTokenFunc.
func (mock *CredsProviderMock) DeleteProjectToken(deleteProjectTokenInput credentials.DeleteProjectTokenInput) (credentials.DeleteProjectTokenOutput, error) {
	if mock.DeleteProjectTokenFunc == nil {
		panic("CredsProviderMock.DeleteProjectTokenFunc: method is nil but Provider.DeleteProjectToken was just called")
	}
	callInfo := struct {
		DeleteProjectTokenInput credentials.DeleteProjectTokenInput
	}{
		DeleteProjectTokenInput: deleteProjectTokenInput,
	}
	mock.lockDeleteProjectToken.Lock()
	mock.calls.DeleteProjectToken = append(mock.calls.DeleteProjectToken, callInfo)
	mock.lockDeleteProjectToken.Unlock()
	return mock.DeleteProjectTokenFunc(deleteProjectTokenInput)
}

// DeleteProjectTokenCalls gets all the calls that were made to DeleteProjectToken.
// Check the length with:
//
//	len(mockedProvider.DeleteProjectTokenCalls())
func (mock *CredsProviderMock) DeleteProjectTokenCalls() []struct {
	DeleteProjectTokenInput credentials.DeleteProjectTokenInput
} {
	var calls []struct {
		DeleteProjectTokenInput credentials.DeleteProjectTokenInput
	}
	mock.lockDeleteProjectToken.RLock()
	calls = mock.calls.DeleteProjectToken
	mock.lockDeleteProjectToken.RUnlock()
	return calls
}

// DeleteTarget calls DeleteTargetFunc.
func (mock *CredsProviderMock) DeleteTarget(deleteTargetInput credentials.DeleteTargetInput) (credentials.DeleteTargetOutput, error) {
	if mock.DeleteTargetFunc == nil {
		panic("CredsProviderMock.DeleteTargetFunc: method is nil but Provider.DeleteTarget was just called")
	}
	callInfo := struct {
		DeleteTargetInput credentials.DeleteTargetInput
	}{
		DeleteTargetInput: deleteTargetInput,
	}
	mock.lockDeleteTarget.Lock()
	mock.calls.DeleteTarget = append(mock.calls.DeleteTarget, callInfo)
	mock.lockDeleteTarget.Unlock()
	return mock.DeleteTargetFunc(deleteTargetInput)
}

// DeleteTargetCalls gets all the calls that were made to DeleteTarget.
// Check the length with:
//
//	len(mockedProvider.DeleteTargetCalls())
func (mock *CredsProviderMock) DeleteTargetCalls() []struct {
	DeleteTargetInput credentials.DeleteTargetInput
} {
	var calls []struct {
		DeleteTargetInput credentials.DeleteTargetInput
	}
	mock.lockDeleteTarget.RLock()
	calls = mock.calls.DeleteTarget
	mock.lockDeleteTarget.RUnlock()
	return calls
}

// GetProject calls GetProjectFunc.
func (mock *CredsProviderMock) GetProject(getProjectInput credentials.GetProjectInput) (credentials.GetProjectOutput, error) {
	if mock.GetProjectFunc == nil {
		panic("CredsProviderMock.GetProjectFunc: method is nil but Provider.GetProject was just called")
	}
	callInfo := struct {
		GetProjectInput credentials.GetProjectInput
	}{
		GetProjectInput: getProjectInput,
	}
	mock.lockGetProject.Lock()
	mock.calls.GetProject = append(mock.calls.GetProject, callInfo)
	mock.lockGetProject.Unlock()
	return mock.GetProjectFunc(getProjectInput)
}

// GetProjectCalls gets all the calls that were made to GetProject.
// Check the length with:
//
//	len(mockedProvider.GetProjectCalls())
func (mock *CredsProviderMock) GetProjectCalls() []struct {
	GetProjectInput credentials.GetProjectInput
} {
	var calls []struct {
		GetProjectInput credentials.GetProjectInput
	}
	mock.lockGetProject.RLock()
	calls = mock.calls.GetProject
	mock.lockGetProject.RUnlock()
	return calls
}

// GetTarget calls GetTargetFunc.
func (mock *CredsProviderMock) GetTarget(getTargetInput credentials.GetTargetInput) (credentials.GetTargetOutput, error) {
	if mock.GetTargetFunc == nil {
		panic("CredsProviderMock.GetTargetFunc: method is nil but Provider.GetTarget was just called")
	}
	callInfo := struct {
		GetTargetInput credentials.GetTargetInput
	}{
		GetTargetInput: getTargetInput,
	}
	mock.lockGetTarget.Lock()
	mock.calls.GetTarget = append(mock.calls.GetTarget, callInfo)
	mock.lockGetTarget.Unlock()
	return mock.GetTargetFunc(getTargetInput)
}

// GetTargetCalls gets all the calls that were made to GetTarget.
// Check the length with:
//
//	len(mockedProvider.GetTargetCalls())
func (mock *CredsProviderMock) GetTargetCalls() []struct {
	GetTargetInput credentials.GetTargetInput
} {
	var calls []struct {
		GetTargetInput credentials.GetTargetInput
	}
	mock.lockGetTarget.RLock()
	calls = mock.calls.GetTarget
	mock.lockGetTarget.RUnlock()
	return calls
}

// GetToken calls GetTokenFunc.
func (mock *CredsProviderMock) GetToken(getTokenInput credentials.GetTokenInput) (credentials.GetTokenOutput, error) {
	if mock.GetTokenFunc == nil {
		panic("CredsProviderMock.GetTokenFunc: method is nil but Provider.GetToken was just called")
	}
	callInfo := struct {
		GetTokenInput credentials.GetTokenInput
	}{
		GetTokenInput: getTokenInput,
	}
	mock.lockGetToken.Lock()
	mock.calls.GetToken = append(mock.calls.GetToken, callInfo)
	mock.lockGetToken.Unlock()
	return mock.GetTokenFunc(getTokenInput)
}

// GetTokenCalls gets all the calls that were made to GetToken.
// Check the length with:
//
//	len(mockedProvider.GetTokenCalls())
func (mock *CredsProviderMock) GetTokenCalls() []struct {
	GetTokenInput credentials.GetTokenInput
} {
	var calls []struct {
		GetTokenInput credentials.GetTokenInput
	}
	mock.lockGetToken.RLock()
	calls = mock.calls.GetToken
	mock.lockGetToken.RUnlock()
	return calls
}

// HealthCheck calls HealthCheckFunc.
func (mock *CredsProviderMock) HealthCheck() (credentials.HealthCheckOutput, error) {
	if mock.HealthCheckFunc == nil {
		panic("CredsProviderMock.HealthCheckFunc: method is nil but Provider.HealthCheck was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHealthCheck.Lock()
	mock.calls.HealthCheck = append(mock.calls.HealthCheck, callInfo)
	mock.lockHealthCheck.Unlock()
	return mock.HealthCheckFunc()
}

// HealthCheckCalls gets all the calls that were made to HealthCheck.
// Check the length with:
//
//	len(mockedProvider.HealthCheckCalls())
func (mock *CredsProviderMock) HealthCheckCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHealthCheck.RLock()
	calls = mock.calls.HealthCheck
	mock.lockHealthCheck.RUnlock()
	return calls
}

// ListTargets calls ListTargetsFunc.
func (mock *CredsProviderMock) ListTargets(listTargetsInput credentials.ListTargetsInput) (credentials.ListTargetsOutput, error) {
	if mock.ListTargetsFunc == nil {
		panic("CredsProviderMock.ListTargetsFunc: method is nil but Provider.ListTargets was just called")
	}
	callInfo := struct {
		ListTargetsInput credentials.ListTargetsInput
	}{
		ListTargetsInput: listTargetsInput,
	}
	mock.lockListTargets.Lock()
	mock.calls.ListTargets = append(mock.calls.ListTargets, callInfo)
	mock.lockListTargets.Unlock()
	return mock.ListTargetsFunc(listTargetsInput)
}

// ListTargetsCalls gets all the calls that were made to ListTargets.
// Check the length with:
//
//	len(mockedProvider.ListTargetsCalls())
func (mock *CredsProviderMock) ListTargetsCalls() []struct {
	ListTargetsInput credentials.ListTargetsInput
} {
	var calls []struct {
		ListTargetsInput credentials.ListTargetsInput
	}
	mock.lockListTargets.RLock()
	calls = mock.calls.ListTargets
	mock.lockListTargets.RUnlock()
	return calls
}

// ProjectExists calls ProjectExistsFunc.
func (mock *CredsProviderMock) ProjectExists(projectExistsInput credentials.ProjectExistsInput) (credentials.ProjectExistsOutput, error) {
	if mock.ProjectExistsFunc == nil {
		panic("CredsProviderMock.ProjectExistsFunc: method is nil but Provider.ProjectExists was just called")
	}
	callInfo := struct {
		ProjectExistsInput credentials.ProjectExistsInput
	}{
		ProjectExistsInput: projectExistsInput,
	}
	mock.lockProjectExists.Lock()
	mock.calls.ProjectExists = append(mock.calls.ProjectExists, callInfo)
	mock.lockProjectExists.Unlock()
	return mock.ProjectExistsFunc(projectExistsInput)
}

// ProjectExistsCalls gets all the calls that were made to ProjectExists.
// Check the length with:
//
//	len(mockedProvider.ProjectExistsCalls())
func (mock *CredsProviderMock) ProjectExistsCalls() []struct {
	ProjectExistsInput credentials.ProjectExistsInput
} {
	var calls []struct {
		ProjectExistsInput credentials.ProjectExistsInput
	}
	mock.lockProjectExists.RLock()
	calls = mock.calls.ProjectExists
	mock.lockProjectExists.RUnlock()
	return calls
}

// ProjectTokenExists calls ProjectTokenExistsFunc.
func (mock *CredsProviderMock) ProjectTokenExists(projectTokenExistsInput credentials.ProjectTokenExistsInput) (credentials.ProjectTokenExistsOutput, error) {
	if mock.ProjectTokenExistsFunc == nil {
		panic("CredsProviderMock.ProjectTokenExistsFunc: method is nil but Provider.ProjectTokenExists was just called")
	}
	callInfo := struct {
		ProjectTokenExistsInput credentials.ProjectTokenExistsInput
	}{
		ProjectTokenExistsInput: projectTokenExistsInput,
	}
	mock.lockProjectTokenExists.Lock()
	mock.calls.ProjectTokenExists = append(mock.calls.ProjectTokenExists, callInfo)
	mock.lockProjectTokenExists.Unlock()
	return mock.ProjectTokenExistsFunc(projectTokenExistsInput)
}

// ProjectTokenExistsCalls gets all the calls that were made to ProjectTokenExists.
// Check the length with:
//
//	len(mockedProvider.ProjectTokenExistsCalls())
func (mock *CredsProviderMock) ProjectTokenExistsCalls() []struct {
	ProjectTokenExistsInput credentials.ProjectTokenExistsInput
} {
	var calls []struct {
		ProjectTokenExistsInput credentials.ProjectTokenExistsInput
	}
	mock.lockProjectTokenExists.RLock()
	calls = mock.calls.ProjectTokenExists
	mock.lockProjectTokenExists.RUnlock()
	return calls
}

// TargetExists calls TargetExistsFunc.
func (mock *CredsProviderMock) TargetExists(targetExistsInput credentials.TargetExistsInput) (credentials.TargetExistsOutput, error) {
	if mock.TargetExistsFunc == nil {
		panic("CredsProviderMock.TargetExistsFunc: method is nil but Provider.TargetExists was just called")
	}
	callInfo := struct {
		TargetExistsInput credentials.TargetExistsInput
	}{
		TargetExistsInput: targetExistsInput,
	}
	mock.lockTargetExists.Lock()
	mock.calls.TargetExists = append(mock.calls.TargetExists, callInfo)
	mock.lockTargetExists.Unlock()
	return mock.TargetExistsFunc(targetExistsInput)
}

// TargetExistsCalls gets all the calls that were made to TargetExists.
// Check the length with:
//
//	len(mockedProvider.TargetExistsCalls())
func (mock *CredsProviderMock) TargetExistsCalls() []struct {
	TargetExistsInput credentials.TargetExistsInput
} {
	var calls []struct {
		TargetExistsInput credentials.TargetExistsInput
	}
	mock.lockTargetExists.RLock()
	calls = mock.calls.TargetExists
	mock.lockTargetExists.RUnlock()
	return calls
}

// UpdateTarget calls UpdateTargetFunc.
func (mock *CredsProviderMock) UpdateTarget(updateTargetInput credentials.UpdateTargetInput) (credentials.UpdateTargetOutput, error) {
	if mock.UpdateTargetFunc == nil {
		panic("CredsProviderMock.UpdateTargetFunc: method is nil but Provider.UpdateTarget was just called")
	}
	callInfo := struct {
		UpdateTargetInput credentials.UpdateTargetInput
	}{
		UpdateTargetInput: updateTargetInput,
	}
	mock.lockUpdateTarget.Lock()
	mock.calls.UpdateTarget = append(mock.calls.UpdateTarget, callInfo)
	mock.lockUpdateTarget.Unlock()
	return mock.UpdateTargetFunc(updateTargetInput)
}

// UpdateTargetCalls gets all the calls that were made to UpdateTarget.
// Check the length with:
//
//	len(mockedProvider.UpdateTargetCalls())
func (mock *CredsProviderMock) UpdateTargetCalls() []struct {
	UpdateTargetInput credentials.UpdateTargetInput
} {
	var calls []struct {
		UpdateTargetInput credentials.UpdateTargetInput
	}
	mock.lockUpdateTarget.RLock()
	calls = mock.calls.UpdateTarget
	mock.lockUpdateTarget.RUnlock()
	return calls
}
