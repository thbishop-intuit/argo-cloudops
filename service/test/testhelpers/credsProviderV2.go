// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testhelpers

import (
	"sync"

	"github.com/cello-proj/cello/service/internal/credentials"
)

// Ensure, that CredsProviderV2Mock does implement credentials.ProviderV2.
// If this is not the case, regenerate this file with moq.
var _ credentials.Provider = &CredsProviderV2Mock{}

// CredsProviderV2Mock is a mock implementation of credentials.ProviderV2.
//
//	func TestSomethingThatUsesProviderV2(t *testing.T) {
//
//		// make and configure a mocked credentials.ProviderV2
//		mockedProviderV2 := &CredsProviderV2Mock{
//			CreateProjectFunc: func(createProjectArgs credentials.CreateProjectArgs) (credentials.CreateProjectResponse, error) {
//				panic("mock out the CreateProject method")
//			},
//			CreateTargetFunc: func(createTargetArgs credentials.CreateTargetArgs) (credentials.CreateTargetResponse, error) {
//				panic("mock out the CreateTarget method")
//			},
//			CreateTokenFunc: func(createTokenArgs credentials.CreateTokenArgs) (credentials.CreateTokenResponse, error) {
//				panic("mock out the CreateToken method")
//			},
//			DeleteProjectFunc: func(deleteProjectArgs credentials.DeleteProjectArgs) (credentials.DeleteProjectResponse, error) {
//				panic("mock out the DeleteProject method")
//			},
//			DeleteProjectTokenFunc: func(deleteProjectTokenArgs credentials.DeleteProjectTokenArgs) (credentials.DeleteProjectTokenResponse, error) {
//				panic("mock out the DeleteProjectToken method")
//			},
//			DeleteTargetFunc: func(deleteTargetArgs credentials.DeleteTargetArgs) (credentials.DeleteTargetResponse, error) {
//				panic("mock out the DeleteTarget method")
//			},
//			GetProjectFunc: func(getProjectArgs credentials.GetProjectArgs) (credentials.GetProjectResponse, error) {
//				panic("mock out the GetProject method")
//			},
//			GetTargetFunc: func(getTargetArgs credentials.GetTargetArgs) (credentials.GetTargetResponse, error) {
//				panic("mock out the GetTarget method")
//			},
//			GetTokenFunc: func(getTokenArgs credentials.GetTokenArgs) (credentials.GetTokenResponse, error) {
//				panic("mock out the GetToken method")
//			},
//			ListTargetsFunc: func(listTargetsArgs credentials.ListTargetsArgs) (credentials.ListTargetsResponse, error) {
//				panic("mock out the ListTargets method")
//			},
//			ProjectExistsFunc: func(projectExistsArgs credentials.ProjectExistsArgs) (credentials.ProjectExistsResponse, error) {
//				panic("mock out the ProjectExists method")
//			},
//			ProjectTokenExistsFunc: func(projectTokenExistsArgs credentials.ProjectTokenExistsArgs) (credentials.ProjectTokenExistsResponse, error) {
//				panic("mock out the ProjectTokenExists method")
//			},
//			TargetExistsFunc: func(targetExistsArgs credentials.TargetExistsArgs) (credentials.TargetExistsResponse, error) {
//				panic("mock out the TargetExists method")
//			},
//			UpdateTargetFunc: func(updateTargetArgs credentials.UpdateTargetArgs) (credentials.UpdateTargetResponse, error) {
//				panic("mock out the UpdateTarget method")
//			},
//		}
//
//		// use mockedProviderV2 in code that requires credentials.ProviderV2
//		// and then make assertions.
//
//	}
type CredsProviderV2Mock struct {
	// CreateProjectFunc mocks the CreateProject method.
	CreateProjectFunc func(createProjectArgs credentials.CreateProjectInput) (credentials.CreateProjectOutput, error)

	// CreateTargetFunc mocks the CreateTarget method.
	CreateTargetFunc func(createTargetArgs credentials.CreateTargetInput) (credentials.CreateTargetOutput, error)

	// CreateTokenFunc mocks the CreateToken method.
	CreateTokenFunc func(createTokenArgs credentials.CreateTokenInput) (credentials.CreateTokenOutput, error)

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(deleteProjectArgs credentials.DeleteProjectInput) (credentials.DeleteProjectOutput, error)

	// DeleteProjectTokenFunc mocks the DeleteProjectToken method.
	DeleteProjectTokenFunc func(deleteProjectTokenArgs credentials.DeleteProjectTokenInput) (credentials.DeleteProjectTokenOutput, error)

	// DeleteTargetFunc mocks the DeleteTarget method.
	DeleteTargetFunc func(deleteTargetArgs credentials.DeleteTargetInput) (credentials.DeleteTargetOutput, error)

	// GetProjectFunc mocks the GetProject method.
	GetProjectFunc func(getProjectArgs credentials.GetProjectInput) (credentials.GetProjectOutput, error)

	// GetTargetFunc mocks the GetTarget method.
	GetTargetFunc func(getTargetArgs credentials.GetTargetInput) (credentials.GetTargetOutput, error)

	// GetTokenFunc mocks the GetToken method.
	GetTokenFunc func(getTokenArgs credentials.GetTokenInput) (credentials.GetTokenOutput, error)

	// ListTargetsFunc mocks the ListTargets method.
	ListTargetsFunc func(listTargetsArgs credentials.ListTargetsInput) (credentials.ListTargetsOutput, error)

	// ProjectExistsFunc mocks the ProjectExists method.
	ProjectExistsFunc func(projectExistsArgs credentials.ProjectExistsInput) (credentials.ProjectExistsOutput, error)

	// ProjectTokenExistsFunc mocks the ProjectTokenExists method.
	ProjectTokenExistsFunc func(projectTokenExistsArgs credentials.ProjectTokenExistsInput) (credentials.ProjectTokenExistsOutput, error)

	// TargetExistsFunc mocks the TargetExists method.
	TargetExistsFunc func(targetExistsArgs credentials.TargetExistsInput) (credentials.TargetExistsOutput, error)

	// UpdateTargetFunc mocks the UpdateTarget method.
	UpdateTargetFunc func(updateTargetArgs credentials.UpdateTargetInput) (credentials.UpdateTargetOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateProject holds details about calls to the CreateProject method.
		CreateProject []struct {
			// CreateProjectArgs is the createProjectArgs argument value.
			CreateProjectArgs credentials.CreateProjectInput
		}
		// CreateTarget holds details about calls to the CreateTarget method.
		CreateTarget []struct {
			// CreateTargetArgs is the createTargetArgs argument value.
			CreateTargetArgs credentials.CreateTargetInput
		}
		// CreateToken holds details about calls to the CreateToken method.
		CreateToken []struct {
			// CreateTokenArgs is the createTokenArgs argument value.
			CreateTokenArgs credentials.CreateTokenInput
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// DeleteProjectArgs is the deleteProjectArgs argument value.
			DeleteProjectArgs credentials.DeleteProjectInput
		}
		// DeleteProjectToken holds details about calls to the DeleteProjectToken method.
		DeleteProjectToken []struct {
			// DeleteProjectTokenArgs is the deleteProjectTokenArgs argument value.
			DeleteProjectTokenArgs credentials.DeleteProjectTokenInput
		}
		// DeleteTarget holds details about calls to the DeleteTarget method.
		DeleteTarget []struct {
			// DeleteTargetArgs is the deleteTargetArgs argument value.
			DeleteTargetArgs credentials.DeleteTargetInput
		}
		// GetProject holds details about calls to the GetProject method.
		GetProject []struct {
			// GetProjectArgs is the getProjectArgs argument value.
			GetProjectArgs credentials.GetProjectInput
		}
		// GetTarget holds details about calls to the GetTarget method.
		GetTarget []struct {
			// GetTargetArgs is the getTargetArgs argument value.
			GetTargetArgs credentials.GetTargetInput
		}
		// GetToken holds details about calls to the GetToken method.
		GetToken []struct {
			// GetTokenArgs is the getTokenArgs argument value.
			GetTokenArgs credentials.GetTokenInput
		}
		// ListTargets holds details about calls to the ListTargets method.
		ListTargets []struct {
			// ListTargetsArgs is the listTargetsArgs argument value.
			ListTargetsArgs credentials.ListTargetsInput
		}
		// ProjectExists holds details about calls to the ProjectExists method.
		ProjectExists []struct {
			// ProjectExistsArgs is the projectExistsArgs argument value.
			ProjectExistsArgs credentials.ProjectExistsInput
		}
		// ProjectTokenExists holds details about calls to the ProjectTokenExists method.
		ProjectTokenExists []struct {
			// ProjectTokenExistsArgs is the projectTokenExistsArgs argument value.
			ProjectTokenExistsArgs credentials.ProjectTokenExistsInput
		}
		// TargetExists holds details about calls to the TargetExists method.
		TargetExists []struct {
			// TargetExistsArgs is the targetExistsArgs argument value.
			TargetExistsArgs credentials.TargetExistsInput
		}
		// UpdateTarget holds details about calls to the UpdateTarget method.
		UpdateTarget []struct {
			// UpdateTargetArgs is the updateTargetArgs argument value.
			UpdateTargetArgs credentials.UpdateTargetInput
		}
	}
	lockCreateProject      sync.RWMutex
	lockCreateTarget       sync.RWMutex
	lockCreateToken        sync.RWMutex
	lockDeleteProject      sync.RWMutex
	lockDeleteProjectToken sync.RWMutex
	lockDeleteTarget       sync.RWMutex
	lockGetProject         sync.RWMutex
	lockGetTarget          sync.RWMutex
	lockGetToken           sync.RWMutex
	lockListTargets        sync.RWMutex
	lockProjectExists      sync.RWMutex
	lockProjectTokenExists sync.RWMutex
	lockTargetExists       sync.RWMutex
	lockUpdateTarget       sync.RWMutex
}

// CreateProject calls CreateProjectFunc.
func (mock *CredsProviderV2Mock) CreateProject(createProjectArgs credentials.CreateProjectInput) (credentials.CreateProjectOutput, error) {
	if mock.CreateProjectFunc == nil {
		panic("CredsProviderV2Mock.CreateProjectFunc: method is nil but ProviderV2.CreateProject was just called")
	}
	callInfo := struct {
		CreateProjectArgs credentials.CreateProjectInput
	}{
		CreateProjectArgs: createProjectArgs,
	}
	mock.lockCreateProject.Lock()
	mock.calls.CreateProject = append(mock.calls.CreateProject, callInfo)
	mock.lockCreateProject.Unlock()
	return mock.CreateProjectFunc(createProjectArgs)
}

// CreateProjectCalls gets all the calls that were made to CreateProject.
// Check the length with:
//
//	len(mockedProviderV2.CreateProjectCalls())
func (mock *CredsProviderV2Mock) CreateProjectCalls() []struct {
	CreateProjectArgs credentials.CreateProjectInput
} {
	var calls []struct {
		CreateProjectArgs credentials.CreateProjectInput
	}
	mock.lockCreateProject.RLock()
	calls = mock.calls.CreateProject
	mock.lockCreateProject.RUnlock()
	return calls
}

// CreateTarget calls CreateTargetFunc.
func (mock *CredsProviderV2Mock) CreateTarget(createTargetArgs credentials.CreateTargetInput) (credentials.CreateTargetOutput, error) {
	if mock.CreateTargetFunc == nil {
		panic("CredsProviderV2Mock.CreateTargetFunc: method is nil but ProviderV2.CreateTarget was just called")
	}
	callInfo := struct {
		CreateTargetArgs credentials.CreateTargetInput
	}{
		CreateTargetArgs: createTargetArgs,
	}
	mock.lockCreateTarget.Lock()
	mock.calls.CreateTarget = append(mock.calls.CreateTarget, callInfo)
	mock.lockCreateTarget.Unlock()
	return mock.CreateTargetFunc(createTargetArgs)
}

// CreateTargetCalls gets all the calls that were made to CreateTarget.
// Check the length with:
//
//	len(mockedProviderV2.CreateTargetCalls())
func (mock *CredsProviderV2Mock) CreateTargetCalls() []struct {
	CreateTargetArgs credentials.CreateTargetInput
} {
	var calls []struct {
		CreateTargetArgs credentials.CreateTargetInput
	}
	mock.lockCreateTarget.RLock()
	calls = mock.calls.CreateTarget
	mock.lockCreateTarget.RUnlock()
	return calls
}

// CreateToken calls CreateTokenFunc.
func (mock *CredsProviderV2Mock) CreateToken(createTokenArgs credentials.CreateTokenInput) (credentials.CreateTokenOutput, error) {
	if mock.CreateTokenFunc == nil {
		panic("CredsProviderV2Mock.CreateTokenFunc: method is nil but ProviderV2.CreateToken was just called")
	}
	callInfo := struct {
		CreateTokenArgs credentials.CreateTokenInput
	}{
		CreateTokenArgs: createTokenArgs,
	}
	mock.lockCreateToken.Lock()
	mock.calls.CreateToken = append(mock.calls.CreateToken, callInfo)
	mock.lockCreateToken.Unlock()
	return mock.CreateTokenFunc(createTokenArgs)
}

// CreateTokenCalls gets all the calls that were made to CreateToken.
// Check the length with:
//
//	len(mockedProviderV2.CreateTokenCalls())
func (mock *CredsProviderV2Mock) CreateTokenCalls() []struct {
	CreateTokenArgs credentials.CreateTokenInput
} {
	var calls []struct {
		CreateTokenArgs credentials.CreateTokenInput
	}
	mock.lockCreateToken.RLock()
	calls = mock.calls.CreateToken
	mock.lockCreateToken.RUnlock()
	return calls
}

// DeleteProject calls DeleteProjectFunc.
func (mock *CredsProviderV2Mock) DeleteProject(deleteProjectArgs credentials.DeleteProjectInput) (credentials.DeleteProjectOutput, error) {
	if mock.DeleteProjectFunc == nil {
		panic("CredsProviderV2Mock.DeleteProjectFunc: method is nil but ProviderV2.DeleteProject was just called")
	}
	callInfo := struct {
		DeleteProjectArgs credentials.DeleteProjectInput
	}{
		DeleteProjectArgs: deleteProjectArgs,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(deleteProjectArgs)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedProviderV2.DeleteProjectCalls())
func (mock *CredsProviderV2Mock) DeleteProjectCalls() []struct {
	DeleteProjectArgs credentials.DeleteProjectInput
} {
	var calls []struct {
		DeleteProjectArgs credentials.DeleteProjectInput
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// DeleteProjectToken calls DeleteProjectTokenFunc.
func (mock *CredsProviderV2Mock) DeleteProjectToken(deleteProjectTokenArgs credentials.DeleteProjectTokenInput) (credentials.DeleteProjectTokenOutput, error) {
	if mock.DeleteProjectTokenFunc == nil {
		panic("CredsProviderV2Mock.DeleteProjectTokenFunc: method is nil but ProviderV2.DeleteProjectToken was just called")
	}
	callInfo := struct {
		DeleteProjectTokenArgs credentials.DeleteProjectTokenInput
	}{
		DeleteProjectTokenArgs: deleteProjectTokenArgs,
	}
	mock.lockDeleteProjectToken.Lock()
	mock.calls.DeleteProjectToken = append(mock.calls.DeleteProjectToken, callInfo)
	mock.lockDeleteProjectToken.Unlock()
	return mock.DeleteProjectTokenFunc(deleteProjectTokenArgs)
}

// DeleteProjectTokenCalls gets all the calls that were made to DeleteProjectToken.
// Check the length with:
//
//	len(mockedProviderV2.DeleteProjectTokenCalls())
func (mock *CredsProviderV2Mock) DeleteProjectTokenCalls() []struct {
	DeleteProjectTokenArgs credentials.DeleteProjectTokenInput
} {
	var calls []struct {
		DeleteProjectTokenArgs credentials.DeleteProjectTokenInput
	}
	mock.lockDeleteProjectToken.RLock()
	calls = mock.calls.DeleteProjectToken
	mock.lockDeleteProjectToken.RUnlock()
	return calls
}

// DeleteTarget calls DeleteTargetFunc.
func (mock *CredsProviderV2Mock) DeleteTarget(deleteTargetArgs credentials.DeleteTargetInput) (credentials.DeleteTargetOutput, error) {
	if mock.DeleteTargetFunc == nil {
		panic("CredsProviderV2Mock.DeleteTargetFunc: method is nil but ProviderV2.DeleteTarget was just called")
	}
	callInfo := struct {
		DeleteTargetArgs credentials.DeleteTargetInput
	}{
		DeleteTargetArgs: deleteTargetArgs,
	}
	mock.lockDeleteTarget.Lock()
	mock.calls.DeleteTarget = append(mock.calls.DeleteTarget, callInfo)
	mock.lockDeleteTarget.Unlock()
	return mock.DeleteTargetFunc(deleteTargetArgs)
}

// DeleteTargetCalls gets all the calls that were made to DeleteTarget.
// Check the length with:
//
//	len(mockedProviderV2.DeleteTargetCalls())
func (mock *CredsProviderV2Mock) DeleteTargetCalls() []struct {
	DeleteTargetArgs credentials.DeleteTargetInput
} {
	var calls []struct {
		DeleteTargetArgs credentials.DeleteTargetInput
	}
	mock.lockDeleteTarget.RLock()
	calls = mock.calls.DeleteTarget
	mock.lockDeleteTarget.RUnlock()
	return calls
}

// GetProject calls GetProjectFunc.
func (mock *CredsProviderV2Mock) GetProject(getProjectArgs credentials.GetProjectInput) (credentials.GetProjectOutput, error) {
	if mock.GetProjectFunc == nil {
		panic("CredsProviderV2Mock.GetProjectFunc: method is nil but ProviderV2.GetProject was just called")
	}
	callInfo := struct {
		GetProjectArgs credentials.GetProjectInput
	}{
		GetProjectArgs: getProjectArgs,
	}
	mock.lockGetProject.Lock()
	mock.calls.GetProject = append(mock.calls.GetProject, callInfo)
	mock.lockGetProject.Unlock()
	return mock.GetProjectFunc(getProjectArgs)
}

// GetProjectCalls gets all the calls that were made to GetProject.
// Check the length with:
//
//	len(mockedProviderV2.GetProjectCalls())
func (mock *CredsProviderV2Mock) GetProjectCalls() []struct {
	GetProjectArgs credentials.GetProjectInput
} {
	var calls []struct {
		GetProjectArgs credentials.GetProjectInput
	}
	mock.lockGetProject.RLock()
	calls = mock.calls.GetProject
	mock.lockGetProject.RUnlock()
	return calls
}

// GetTarget calls GetTargetFunc.
func (mock *CredsProviderV2Mock) GetTarget(getTargetArgs credentials.GetTargetInput) (credentials.GetTargetOutput, error) {
	if mock.GetTargetFunc == nil {
		panic("CredsProviderV2Mock.GetTargetFunc: method is nil but ProviderV2.GetTarget was just called")
	}
	callInfo := struct {
		GetTargetArgs credentials.GetTargetInput
	}{
		GetTargetArgs: getTargetArgs,
	}
	mock.lockGetTarget.Lock()
	mock.calls.GetTarget = append(mock.calls.GetTarget, callInfo)
	mock.lockGetTarget.Unlock()
	return mock.GetTargetFunc(getTargetArgs)
}

// GetTargetCalls gets all the calls that were made to GetTarget.
// Check the length with:
//
//	len(mockedProviderV2.GetTargetCalls())
func (mock *CredsProviderV2Mock) GetTargetCalls() []struct {
	GetTargetArgs credentials.GetTargetInput
} {
	var calls []struct {
		GetTargetArgs credentials.GetTargetInput
	}
	mock.lockGetTarget.RLock()
	calls = mock.calls.GetTarget
	mock.lockGetTarget.RUnlock()
	return calls
}

// GetToken calls GetTokenFunc.
func (mock *CredsProviderV2Mock) GetToken(getTokenArgs credentials.GetTokenInput) (credentials.GetTokenOutput, error) {
	if mock.GetTokenFunc == nil {
		panic("CredsProviderV2Mock.GetTokenFunc: method is nil but ProviderV2.GetToken was just called")
	}
	callInfo := struct {
		GetTokenArgs credentials.GetTokenInput
	}{
		GetTokenArgs: getTokenArgs,
	}
	mock.lockGetToken.Lock()
	mock.calls.GetToken = append(mock.calls.GetToken, callInfo)
	mock.lockGetToken.Unlock()
	return mock.GetTokenFunc(getTokenArgs)
}

// GetTokenCalls gets all the calls that were made to GetToken.
// Check the length with:
//
//	len(mockedProviderV2.GetTokenCalls())
func (mock *CredsProviderV2Mock) GetTokenCalls() []struct {
	GetTokenArgs credentials.GetTokenInput
} {
	var calls []struct {
		GetTokenArgs credentials.GetTokenInput
	}
	mock.lockGetToken.RLock()
	calls = mock.calls.GetToken
	mock.lockGetToken.RUnlock()
	return calls
}

// ListTargets calls ListTargetsFunc.
func (mock *CredsProviderV2Mock) ListTargets(listTargetsArgs credentials.ListTargetsInput) (credentials.ListTargetsOutput, error) {
	if mock.ListTargetsFunc == nil {
		panic("CredsProviderV2Mock.ListTargetsFunc: method is nil but ProviderV2.ListTargets was just called")
	}
	callInfo := struct {
		ListTargetsArgs credentials.ListTargetsInput
	}{
		ListTargetsArgs: listTargetsArgs,
	}
	mock.lockListTargets.Lock()
	mock.calls.ListTargets = append(mock.calls.ListTargets, callInfo)
	mock.lockListTargets.Unlock()
	return mock.ListTargetsFunc(listTargetsArgs)
}

// ListTargetsCalls gets all the calls that were made to ListTargets.
// Check the length with:
//
//	len(mockedProviderV2.ListTargetsCalls())
func (mock *CredsProviderV2Mock) ListTargetsCalls() []struct {
	ListTargetsArgs credentials.ListTargetsInput
} {
	var calls []struct {
		ListTargetsArgs credentials.ListTargetsInput
	}
	mock.lockListTargets.RLock()
	calls = mock.calls.ListTargets
	mock.lockListTargets.RUnlock()
	return calls
}

// ProjectExists calls ProjectExistsFunc.
func (mock *CredsProviderV2Mock) ProjectExists(projectExistsArgs credentials.ProjectExistsInput) (credentials.ProjectExistsOutput, error) {
	if mock.ProjectExistsFunc == nil {
		panic("CredsProviderV2Mock.ProjectExistsFunc: method is nil but ProviderV2.ProjectExists was just called")
	}
	callInfo := struct {
		ProjectExistsArgs credentials.ProjectExistsInput
	}{
		ProjectExistsArgs: projectExistsArgs,
	}
	mock.lockProjectExists.Lock()
	mock.calls.ProjectExists = append(mock.calls.ProjectExists, callInfo)
	mock.lockProjectExists.Unlock()
	return mock.ProjectExistsFunc(projectExistsArgs)
}

// ProjectExistsCalls gets all the calls that were made to ProjectExists.
// Check the length with:
//
//	len(mockedProviderV2.ProjectExistsCalls())
func (mock *CredsProviderV2Mock) ProjectExistsCalls() []struct {
	ProjectExistsArgs credentials.ProjectExistsInput
} {
	var calls []struct {
		ProjectExistsArgs credentials.ProjectExistsInput
	}
	mock.lockProjectExists.RLock()
	calls = mock.calls.ProjectExists
	mock.lockProjectExists.RUnlock()
	return calls
}

// ProjectTokenExists calls ProjectTokenExistsFunc.
func (mock *CredsProviderV2Mock) ProjectTokenExists(projectTokenExistsArgs credentials.ProjectTokenExistsInput) (credentials.ProjectTokenExistsOutput, error) {
	if mock.ProjectTokenExistsFunc == nil {
		panic("CredsProviderV2Mock.ProjectTokenExistsFunc: method is nil but ProviderV2.ProjectTokenExists was just called")
	}
	callInfo := struct {
		ProjectTokenExistsArgs credentials.ProjectTokenExistsInput
	}{
		ProjectTokenExistsArgs: projectTokenExistsArgs,
	}
	mock.lockProjectTokenExists.Lock()
	mock.calls.ProjectTokenExists = append(mock.calls.ProjectTokenExists, callInfo)
	mock.lockProjectTokenExists.Unlock()
	return mock.ProjectTokenExistsFunc(projectTokenExistsArgs)
}

// ProjectTokenExistsCalls gets all the calls that were made to ProjectTokenExists.
// Check the length with:
//
//	len(mockedProviderV2.ProjectTokenExistsCalls())
func (mock *CredsProviderV2Mock) ProjectTokenExistsCalls() []struct {
	ProjectTokenExistsArgs credentials.ProjectTokenExistsInput
} {
	var calls []struct {
		ProjectTokenExistsArgs credentials.ProjectTokenExistsInput
	}
	mock.lockProjectTokenExists.RLock()
	calls = mock.calls.ProjectTokenExists
	mock.lockProjectTokenExists.RUnlock()
	return calls
}

// TargetExists calls TargetExistsFunc.
func (mock *CredsProviderV2Mock) TargetExists(targetExistsArgs credentials.TargetExistsInput) (credentials.TargetExistsOutput, error) {
	if mock.TargetExistsFunc == nil {
		panic("CredsProviderV2Mock.TargetExistsFunc: method is nil but ProviderV2.TargetExists was just called")
	}
	callInfo := struct {
		TargetExistsArgs credentials.TargetExistsInput
	}{
		TargetExistsArgs: targetExistsArgs,
	}
	mock.lockTargetExists.Lock()
	mock.calls.TargetExists = append(mock.calls.TargetExists, callInfo)
	mock.lockTargetExists.Unlock()
	return mock.TargetExistsFunc(targetExistsArgs)
}

// TargetExistsCalls gets all the calls that were made to TargetExists.
// Check the length with:
//
//	len(mockedProviderV2.TargetExistsCalls())
func (mock *CredsProviderV2Mock) TargetExistsCalls() []struct {
	TargetExistsArgs credentials.TargetExistsInput
} {
	var calls []struct {
		TargetExistsArgs credentials.TargetExistsInput
	}
	mock.lockTargetExists.RLock()
	calls = mock.calls.TargetExists
	mock.lockTargetExists.RUnlock()
	return calls
}

// UpdateTarget calls UpdateTargetFunc.
func (mock *CredsProviderV2Mock) UpdateTarget(updateTargetArgs credentials.UpdateTargetInput) (credentials.UpdateTargetOutput, error) {
	if mock.UpdateTargetFunc == nil {
		panic("CredsProviderV2Mock.UpdateTargetFunc: method is nil but ProviderV2.UpdateTarget was just called")
	}
	callInfo := struct {
		UpdateTargetArgs credentials.UpdateTargetInput
	}{
		UpdateTargetArgs: updateTargetArgs,
	}
	mock.lockUpdateTarget.Lock()
	mock.calls.UpdateTarget = append(mock.calls.UpdateTarget, callInfo)
	mock.lockUpdateTarget.Unlock()
	return mock.UpdateTargetFunc(updateTargetArgs)
}

// UpdateTargetCalls gets all the calls that were made to UpdateTarget.
// Check the length with:
//
//	len(mockedProviderV2.UpdateTargetCalls())
func (mock *CredsProviderV2Mock) UpdateTargetCalls() []struct {
	UpdateTargetArgs credentials.UpdateTargetInput
} {
	var calls []struct {
		UpdateTargetArgs credentials.UpdateTargetInput
	}
	mock.lockUpdateTarget.RLock()
	calls = mock.calls.UpdateTarget
	mock.lockUpdateTarget.RUnlock()
	return calls
}
